# .github/workflows/ci.yml
name: CI # A short name shown in the Actions tab

on:
  push:
    branches: [main] # Run on pushes to main
  pull_request: # And on any PR (any branch â†’ main)

# Prevents piling up runs for the same ref (branch); newest run cancels older ones.
concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

# Least-privilege token for the job (only needs to read the repo).
permissions:
  contents: read

jobs:
  test-build: # Single job named "test-build"
    runs-on: ubuntu-latest # GitHub-hosted Linux runner

    steps:
      # 1) Check out your code
      - uses: actions/checkout@v4

      # 2) Install pnpm CLI (we use pnpm because your repo has pnpm-lock.yaml)
      - uses: pnpm/action-setup@v4
        with:
          version: 9

      # 3) Install Node and enable pnpm cache based on lockfile
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      # 4) Install dependencies exactly as pinned in pnpm-lock.yaml
      - name: Install deps
        run: pnpm install --frozen-lockfile

      # 5) Generate Prisma Client (needed for build/test that import it)
      - name: Generate Prisma
        run: pnpm prisma generate

      # 6) Lint the codebase with ESLint (fails the build on lint errors)
      - name: Lint
        run: pnpm lint

      # 7) Run the test suite; force in-band if your tests touch globals/ports
      - name: Test
        env:
          NODE_ENV: test
          JWT_SECRET: testsecret
          JWT_ISSUER: myapi
          JWT_AUDIENCE: myapi-clients
        run: pnpm test -- --runInBand

      # 8) TypeScript build (produces dist/)
      - name: Build
        run: pnpm build
